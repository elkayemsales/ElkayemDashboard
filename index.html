<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elkayem Dashboard</title>
  <link rel="icon" href="https://1drv.ms/i/c/4ab693cd2bf36664/IQTr7ZSuh7O8QLKuxXi2-O6sAYJZMA6tE-ZmCfHweVYiK98?width=136&height=58" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

  <style>
    /* style.css */

    :root{
      --primary: #d97706;
      --primary-light: #fbbf24;
      --bg-light: #fdf6e3;
      --text-light: #4b3f2f;
      --sidebar-bg: #f4e3c3;
      --sidebar-hover: #edd9b0;
      --bg-dark: #111213;
      --text-dark: #e6e6e6;
      --sidebar-bg-dark: #1f1f1f;
      --sidebar-hover-dark: #2a2a2a;
      --sidebar-width: 220px;
      --sidebar-collapsed-width: 60px;
      --iframe-ref-w: 1280;   /* reference width for auto-fit */
      --header-height-desktop: 64px;
      --toast-duration: 2200ms;
      --zoom-min: 40;   /* percent */
      --zoom-max: 150;  /* percent */
    }

    /* Reset & base */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background:var(--bg-light);
      color:var(--text-light);
      display:flex;
      min-height:100vh;
      overflow:hidden;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    body.dark-mode{
      background:var(--bg-dark);
      color:var(--text-dark);
    }

    /* Professional Sidebar */
    nav.sidebar{
      width:var(--sidebar-width);
      flex-shrink: 0;
      background: linear-gradient(180deg, var(--sidebar-bg) 0%, rgba(255,255,255,0.04) 100%);
      display:flex;
      flex-direction:column;
      padding:12px 10px 92px 12px;
      gap:10px;
      /* Ensure smooth transition of width on desktop */
      transition:width .28s ease, background .28s ease, left .28s ease;
      z-index:1400;
      box-shadow: 2px 0 14px rgba(0,0,0,0.06);
      border-right: 1px solid rgba(0,0,0,0.03);
    }
    body.dark-mode nav.sidebar{ background: linear-gradient(180deg, var(--sidebar-bg-dark) 0%, rgba(255,255,255,0.02) 100%); box-shadow: 2px 0 18px rgba(0,0,0,0.35); border-right: 1px solid rgba(255,255,255,0.03); }
    nav.sidebar.collapsed{ width:var(--sidebar-collapsed-width); align-items:center; padding-left:6px }

    nav.sidebar a{
      position:relative;
      display:flex; align-items:center;
      gap:12px;
      padding:12px;
      color:var(--text-light);
      text-decoration:none;
      border-radius:10px;
      font-weight:600;
      transition:background .18s, color .18s, transform .12s;
      cursor:pointer;
      white-space:nowrap;
      min-height:44px;
    }
    body.dark-mode nav.sidebar a{ color:var(--text-dark) }
    nav.sidebar a i{ font-size:18px; width:24px; text-align:center; color:inherit; }
    nav.sidebar a:hover{ transform:translateX(4px); background:var(--sidebar-hover); color:#000; }
    body.dark-mode nav.sidebar a:hover{ background:var(--sidebar-hover-dark); color:#fff }

    nav.sidebar a.active{ background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%); color:#fff; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    nav.sidebar a.active::before{ content:""; position:absolute; left:0; top:8px; bottom:8px; width:4px; background:var(--primary-light); border-radius:4px; }

    nav.sidebar.collapsed a{ justify-content:center; gap:0; font-size:0; padding-right:0; padding-left:0; width:48px }
    nav.sidebar.collapsed a span{ display:none; }
    nav.sidebar.collapsed a[data-label]::after{ content: attr(data-label); position:absolute; left:100%; top:50%; transform:translateY(-50%) translateX(10px); background: rgba(0,0,0,0.78); color:#fff; padding:6px 8px; border-radius:6px; font-size:13px; white-space:nowrap; opacity:0; pointer-events:none; transition:opacity .18s; z-index:1600; }
    nav.sidebar.collapsed a:hover::after{ opacity:1; }

    #sidebarToggle{ 
      margin-top:auto; align-self:center; 
      background:var(--primary); color:#fff; border:none; border-radius:50%; 
      width:48px; height:48px; display:flex; align-items:center; justify-content:center; 
      cursor:pointer; box-shadow:0 8px 24px rgba(0,0,0,0.12); transition:transform .18s, background .18s; 
      margin-bottom: 20px;
    }
    #sidebarToggle:hover{ background: var(--primary-light); transform:rotate(12deg) }

    /* main area */
    .main-content{ flex:1; display:flex; flex-direction:column; min-width:0; height:100vh }

    /* header */
    .page-header{
      height:var(--header-height-desktop);
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 20px; background:var(--bg-light); border-bottom:1px solid #e5e7eb;
      position:relative; font-weight:700; font-size:18px; color:var(--text-light);
      transition:background .25s, color .25s;
      flex-wrap:nowrap;
    }
    body.dark-mode .page-header{ background: transparent; color:var(--text-dark); border-color: rgba(255,255,255,0.04); }
    .header-title{ display:flex; align-items:center; gap:12px; flex:1; text-align:left; min-width:0; overflow:hidden }
    #titleText { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .actions{ display:flex; gap:8px; align-items:center; flex-wrap:nowrap; margin-left:16px; flex-shrink:0 }
    .actions button{ 
      background:var(--primary); color:#fff; border:none; padding:8px 10px; border-radius:8px; 
      cursor:pointer; font-weight:600; transition:background .18s, transform .12s;
    }
    .actions button:hover { background: var(--primary-light); }
    .actions button:active{ transform:translateY(1px) }

    .zoom-control{ display:flex; align-items:center; gap:8px; margin-right:6px; font-size:13px; flex-shrink:0 }
    .zoom-control input[type="range"]{ width:120px; min-width:80px; }

    /* iframe area */
    .iframe-container{ flex:1; position:relative; overflow:hidden; background: #fff; -webkit-overflow-scrolling:touch }
    body.dark-mode .iframe-container{ background:#0b0b0b }

    .iframe-viewport{ width:100%; height:100%; overflow:auto; position:relative; display:flex; justify-content:center; align-items:flex-start; touch-action:pan-x pan-y }
    .iframe-shell{
      width:100%;
      max-width: calc(var(--iframe-ref-w) * 1px);
      min-width: 320px;
      margin:12px 0; /* Only vertical margin remains. Horizontal positioning controlled by JS centering. */
      transition: transform .12s ease;
      transform-origin: top left;
      position:relative;
      background:transparent;
      overflow:hidden; 
      resize: both;
    }
    .iframe-shell iframe{ 
      width:100%; 
      height: 720px; /* Default fallback height, dynamically set by JS */
      border-radius:8px; border:1px solid rgba(0,0,0,0.08); display:block;
      transition: height 0.3s ease; 
    }
    body.dark-mode .iframe-shell iframe { border-color: rgba(255,255,255,0.12); }


    /* resizer handle */
    .resize-handle{
      position:absolute; right:6px; bottom:6px; width:20px; height:20px;
      background: repeating-linear-gradient(45deg, rgba(0,0,0,0.12) 0 2px, transparent 2px 4px);
      border-radius:3px; cursor:se-resize; z-index:1600;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
    }
    .resize-handle:active{ filter:brightness(.95) }

    /* iframe controls (zoom buttons) */
    .iframe-controls{ 
      position:absolute; bottom:14px; right:14px; display:flex; gap:6px; z-index:1500;
      padding: 8px;
    }
    .iframe-controls button{ 
      background:rgba(0,0,0,0.6); color:#fff; border:none; 
      width:40px; height:40px; border-radius:10px; cursor:pointer; 
      display:flex; align-items:center; justify-content:center; font-weight:700;
      font-size: 16px;
      transition: background .18s;
    }
    .iframe-controls button:hover{ background:rgba(0,0,0,0.8) }

    /* loading */
    .loading-spinner{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:var(--primary); font-weight:700; display:none; z-index:1400 }
    .loading-spinner.active{ display:block }

    /* toast (centered) */
    .toast{ 
      position:fixed;
      bottom:24px; 
      left:50%; 
      transform:translateX(-50%) translateY(12px); 
      background:var(--primary); color:#fff; padding:10px 16px; border-radius:10px; 
      box-shadow:0 10px 30px rgba(0,0,0,0.18);
      opacity:0; transition:all .26s; z-index:2200;
      max-width: 90%;
      text-align: center;
      pointer-events: none;
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); } 

    /* debug panel */
    #debugPanel{ position:fixed; left:12px; bottom:12px; width:320px; max-height:360px; background:rgba(0,0,0,0.8); color:#fff; font-size:12px; border-radius:8px; overflow:auto; z-index:2300; display:none }
    #debugPanel.open{ display:block }

    /* responsive adjustments */
    @media (max-width:768px){
      /* Mobile header adjustments */
      .page-header{ 
        height:auto;
        align-items:flex-start; 
        flex-direction: column; 
        padding-bottom: 10px; 
      }
      .header-title{ width:100%; font-size:16px; margin-bottom: 8px; }
      
      /* Mobile actions layout */
      .actions{ 
        width:100%; gap:6px; margin-top:0; margin-left:0;
        flex-wrap: wrap; 
        justify-content: space-between;
      }
      .actions button{ flex:1 1 30%; min-width:80px; padding: 6px 8px; font-size: 13px; }
      
      /* Zoom controls on their own line */
      .zoom-control{ flex-basis:100%; margin-bottom:0; justify-content: space-between; }

      /* Mobile sidebar (drawer) - OFF CANVAS + NO DARKNESS */
      nav.sidebar{ 
        position:fixed; left:-300px; top:0; height:100vh; width:var(--sidebar-width);
        box-shadow: 2px 0 14px rgba(0,0,0,0.1); 
        padding-top: 60px;
        background: var(--sidebar-bg);
      }
      body.dark-mode nav.sidebar{
        box-shadow: 2px 0 18px rgba(0,0,0,0.35);
      }
      nav.sidebar.open{ left:0 }
      nav.sidebar.collapsed{ width:var(--sidebar-width) } 
      
      /* Clean up iframe margins for edge-to-edge mobile view */
      .iframe-shell{ margin: 0; }
      .iframe-shell iframe{ border-radius: 0; border: none; }
      
      /* Mobile sidebar toggle button fixed position */
      #sidebarToggle{ 
        position:fixed; 
        left:20px; bottom:20px; z-index:2500; 
        box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        margin-bottom: 0;
      }
    }
  </style>
</head>

<body>
  <nav class="sidebar" id="sidebar" aria-label="Sidebar navigation">
    <button id="sidebarToggle" aria-label="Toggle sidebar">
      <i class="fas fa-chevron-left"></i>
    </button>
  </nav>

  <div class="main-content" id="mainContent">
    <header class="page-header" id="pageHeader" role="banner">
      <div class="header-title" id="headerTitle">
        <span id="titleText">Elkayem Dashboard</span>
      </div>

      <div class="actions" role="region" aria-label="Dashboard actions">
        <div class="zoom-control" title="Zoom / scale">
          <span id="zoomPct" class="zoom-label">Auto</span>
          <input id="zoomSlider" type="range" min="40" max="150" step="1" value="100" aria-label="Zoom slider" />
          <label style="display:flex;align-items:center;gap:6px;font-size:13px">
            <input id="autoScaleCheckbox" type="checkbox" checked /> Auto
          </label>
        </div>

        <button id="refreshBtn" aria-label="Refresh Dashboard">Refresh</button>
        <button id="darkToggle" aria-label="Toggle dark mode">Dark</button>
        <button id="debugToggle" aria-label="Toggle debug panel">Logs</button>
      </div>
    </header>

    <section class="iframe-container" aria-live="polite" aria-busy="false" id="iframeContainer">
      <div id="loading" class="loading-spinner" aria-hidden="true">Loading...</div>

      <div class="iframe-viewport" id="iframeViewport">
        <div class="iframe-shell" id="iframeShell">
          <div class="resize-handle" id="resizeHandle" title="Drag to resize (double-click to auto)"></div>
        </div>

        <div class="iframe-controls" id="iframeControls" aria-hidden="false">
          <button id="zoomInBtn" title="Zoom In">+</button>
          <button id="zoomOutBtn" title="Zoom Out">−</button>
          <button id="zoomResetBtn" title="Reset Zoom">⟳</button>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <div id="debugPanel" aria-hidden="true">
    <div style="padding:8px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,0.06);">
      <strong>Debug</strong>
      <div>
        <button id="debugClear" style="margin-right:8px">Clear</button>
        <button id="debugClose">Close</button>
      </div>
    </div>
    <div id="debugBody" style="padding:8px; max-height:300px; overflow:auto; font-size:12px;"></div>
  </div>

  <script>
   
   // --- 3.1. CONFIGURATION (Externalized from HTML) ---
    const DASHBOARD_CONFIG = [
      { 
        id: 'six-years', label: 'Six Years',icon: 'calendar-alt',
        url: 'https://1drv.ms/x/c/468679d4cdf834af/IQRbLRTxiaelQpasWOl9FT1AAUQgww0W2oJtk91grCx4FA0?em=2&AllowTyping=True&ActiveCell=\'TVSM\'!F12&wdHideGridlines=True&wdHideHeaders=True&wdInConfigurator=True' 
      },
{ 
        id: 'proj-pes', 
        label: 'Projection PES',  
        icon: 'bullseye',
        // REFRAMED: Using your latest iframe source and ensuring valid JavaScript syntax
        url: "https://1drv.ms/x/c/468679d4cdf834af/IQTdrEGtuCyGTpq-v3Q6hsKuAYKGmjsuTKebugPDxc4FXRw?em=2&AllowTyping=True&ActiveCell='SUM(V)'!I21&wdHideGridlines=True&wdHideHeaders=True&wdInConfigurator=True"
      },
      { 
        id: 'plan-actual', label: 'Plan vs Actual', icon: 'chart-line', 
        url: 'https://1drv.ms/x/c/468679d4cdf834af/IQRh64wtQXqRTZI8GV4iHS8DAeh6c0mtWC4h9a-CAlhQgJQ?em=2&AllowTyping=True&ActiveCell=\'Print%20Sum\'!D11&wdenablegridlines=False' 
      },
      { 
        id: 'mis-report', label: 'MIS Report', icon: 'table', 
        url: 'https://1drv.ms/x/c/468679d4cdf834af/IQTHRO0Qsx2hTI2ZRkGHKJeZAZJp8HXMQyh7p0wgucGxOLA?em=2&AllowTyping=True&ActiveCell=\'MIS\'!&wdenablegridlines=False' 
      },
      { 
        id: 'jit-call', label: 'Jit Call Performance', icon: 'tools', 
        url: 'https://1drv.ms/x/c/468679d4cdf834af/IQSNZZ46TxqgSorM-BcNSAMYAdyeRYhRbzJMd4juqqrCYYk?em=2&AllowTyping=True&ActiveCell=\'25-26%20Analysis\'!G37&wdenablegridlines=False' 
      },
      { id: 'elkayem-parts', label: 'Elkayem Parts', icon: 'cogs', url: 'https://elkayemsales.github.io/ElkayemSupplyingParts/' },
      { id: 'sales-rr', label: 'Sales R&R', icon: 'briefcase', url: 'https://elkayemsales.github.io/Sales-Roles-Responsibilities/' },
    ];
    // --- 3.2. UTILITY FUNCTIONS ---

    /**
     * Custom logger that writes to both console and the on-screen debug panel.
     * @param {HTMLElement} debugBody - The container for debug logs.
     * @returns {function(string): void} The logging function.
     */
    function createLogger(debugBody) {
        return function logDebug(msg) {
            const ts = new Date().toLocaleTimeString();
            const line = `[${ts}] ${msg}`;
            console.log(line);
            const d = document.createElement('div');
            d.textContent = line;
            debugBody.prepend(d);
        };
    }

    /**
     * Debounce function for rate-limiting events like 'resize'.
     * @param {Function} fn - The function to debounce.
     * @param {number} ms - The delay in milliseconds.
     * @returns {Function} The debounced function.
     */
    function debounce(fn, ms) {
        let t;
        return (...a) => {
            if (t) clearTimeout(t);
            t = setTimeout(() => fn(...a), ms);
        };
    }

    // --- 3.3. PREFERENCE/STATE MANAGER ---
    const PrefManager = {
        /**
         * Sets a preference item in local storage.
         * @param {string} k - The key.
         * @param {string} v - The value.
         */
        setPref(k, v) {
            const prefixedKey = 'ek_' + k;
            try {
                localStorage.setItem(prefixedKey, v);
            } catch (e) {
                // Fallback to cookie storage if local storage fails
                document.cookie = `${prefixedKey}=${encodeURIComponent(v)}; path=/; max-age=${60*60*24*365}`;
            }
        },
        /**
         * Gets a preference item from local storage.
         * @param {string} k - The key.
         * @returns {string | null} The stored value or null.
         */
        getPref(k) {
            const prefixedKey = 'ek_' + k;
            try {
                const value = localStorage.getItem(prefixedKey);
                if (value !== null) return value;
            } catch (e) {
                // Ignore error, try cookie fallback
            }
            
            // Cookie fallback
            return document.cookie.split('; ').reduce((r, v) => {
                const parts = v.split('=');
                return parts[0].trim() === prefixedKey ? decodeURIComponent(parts.slice(1).join('=')) : r
            }, null)
        }
    };

    // --- 3.4. CORE APPLICATION LOGIC ---
    /**
     * @typedef {Object} DashboardConfig
     * @property {string} id - Unique ID for deep linking/state management.
     * @property {string} label - Display name.
     * @property {string} icon - Font Awesome icon class fragment (e.g., 'calendar-alt').
     * @property {string} url - The URL to load in the iframe.
     */

    class DashboardApp {
        /**
         * @param {Object<string, HTMLElement>} elements - Map of key DOM elements.
         * @param {DashboardConfig[]} config - The array of dashboard configurations.
         */
        constructor(elements, config) {
            this.el = elements;
            this.config = config;
            this.log = createLogger(this.el.debugBody);

            this._iframeMap = new Map();         // id -> iframe element
            this._iframeLoadState = new Map();   // id -> boolean (is loading?)
            /** @type {DashboardConfig | null} */
            this._currentConfig = null;
            this._manualScale = null;
            this._lastScale = 1;
            this.navLinks = [];                  // Array of dynamically created <a> elements

            // Configuration from CSS variables (robustly retrieved)
            const style = getComputedStyle(document.documentElement);
            this.REF_W = Number(style.getPropertyValue('--iframe-ref-w').trim()) || 1280;
            this.ZOOM_MIN = Number(style.getPropertyValue('--zoom-min').trim()) / 100 || 0.4;
            this.ZOOM_MAX = Number(style.getPropertyValue('--zoom-max').trim()) / 100 || 1.5;
            this.TOAST_DURATION = parseInt(style.getPropertyValue('--toast-duration').trim()) || 2200;

            this._buildSidebar();
            this.init();
            this.bindEvents();
        }

        /**
         * Dynamically generates the sidebar navigation from the config array.
         * @private
         */
        _buildSidebar = () => {
            const toggleButton = this.el.sidebarToggle;
            const sidebar = this.el.sidebar;
            
            // Remove the toggle button temporarily
            if (toggleButton) sidebar.removeChild(toggleButton);

            this.config.forEach(item => {
                const a = document.createElement('a');
                a.href = `#${item.id}`;
                a.setAttribute('data-id', item.id);
                a.setAttribute('data-label', item.label);
                a.innerHTML = `<i class="fa-solid fa-${item.icon}"></i><span>${item.label}</span>`;
                this.navLinks.push(a);
                sidebar.appendChild(a);
            });

            // Re-add the toggle button at the end
            if (toggleButton) sidebar.appendChild(toggleButton);
        }

        /**
         * Finds a config item by its ID.
         * @param {string} id 
         * @returns {DashboardConfig | undefined}
         */
        _getConfigById = (id) => {
            return this.config.find(c => c.id === id);
        }

        /**
         * Displays a toast notification.
         * @param {string} msg - The message to show.
         * @param {number} [ms] - Duration in milliseconds.
         */
        showToast = (msg, ms = this.TOAST_DURATION) => {
            if (this.toastTimer) clearTimeout(this.toastTimer);
            this.el.toastEl.textContent = msg;
            this.el.toastEl.classList.add('show');
            this.toastTimer = setTimeout(() => this.el.toastEl.classList.remove('show'), ms);
            this.log('TOAST: ' + msg);
        }

        /** Shows the loading spinner. */
        showLoading = () => {
            this.el.loading.classList.add('active');
            this.el.loading.setAttribute('aria-hidden', 'false');
            this.el.iframeViewport.setAttribute('aria-busy', 'true');
        }

        /** Hides the loading spinner. */
        hideLoading = () => {
            this.el.loading.classList.remove('active');
            this.el.loading.setAttribute('aria-hidden', 'true');
            this.el.iframeViewport.setAttribute('aria-busy', 'false');
        }

        /** * Calculates the dynamic height for the currently active iframe.
         * This ensures the iframe perfectly fills the space below the header on all screens.
         * @private
         */
        _calculateIframeHeight = () => {
            if (this.el.iframeShell.style.height) return; // Ignore if manual resize is active

            const headerHeight = this.el.pageHeader.offsetHeight;
            let paddingBottom = window.innerWidth > 768 ? 24 : 
                               (this.el.iframeControls.offsetHeight + 20); // Desktop vs Mobile margin
            
            const contentHeight = `calc(100vh - ${headerHeight}px - ${paddingBottom}px)`;
            
            const activeFrame = this.el.iframeShell.querySelector('iframe.active');
            if (activeFrame) {
                activeFrame.style.height = contentHeight;
            }
        }


        /**
         * Calculates and applies the scaling transformation to the iframe shell.
         */
        scaleViewport = () => {
            const vpW = this.el.iframeViewport.clientWidth;
            if (!vpW) return;

            const autoScale = Math.min(vpW / this.REF_W, 1.0);
            const scale = (this._manualScale && this._manualScale > 0) ? this._manualScale : autoScale;
            this._lastScale = scale;

            this.el.iframeShell.style.transform = `scale(${scale})`;
            this.el.iframeShell.style.transformOrigin = 'top left';

            // Center horizontally
            const shellDisplayWidth = this.REF_W * scale;
            const leftoverX = Math.max(0, (vpW - shellDisplayWidth) / 2);
            this.el.iframeShell.style.marginLeft = leftoverX + 'px';

            // Update UI label
            if (this._manualScale) {
                this.el.zoomPct.textContent = `${Math.round(this._manualScale * 100)}%`;
            } else {
                this.el.zoomPct.textContent = `Auto (${Math.round(scale * 100)}%)`;
            }
            
            this._calculateIframeHeight();
        }

        /**
         * Preloads the first few iframes lazily during idle time.
         * @param {number} [limit=2] - Number of iframes to preload.
         */
        preload = (limit = 2) => {
            const configs = this.config;
            let i = 0;
            const loadOne = (c) => {
                if (!c || this._iframeMap.has(c.id)) return;
                const f = document.createElement('iframe');
                f.src = c.url;
                f.loading = 'lazy';
                f.style.display = 'none';
                f.referrerPolicy = 'no-referrer-when-downgrade';
                f.setAttribute('sandbox', 'allow-scripts allow-forms allow-same-origin allow-popups'); 

                f.onload = () => {
                    this._iframeLoadState.set(c.id, false);
                    this.log('Preloaded ' + c.label);
                };
                f.onerror = () => {
                    this._iframeLoadState.set(c.id, false);
                    this.log('Preload failed ' + c.label);
                };
                this._iframeLoadState.set(c.id, true);
                this._iframeMap.set(c.id, f);
                this.el.iframeShell.appendChild(f);
            };

            const schedule = () => {
                while (i < Math.min(limit, configs.length)) {
                    const c = configs[i++];
                    // Skip preloading the actively loaded sheet
                    if (this._currentConfig && c.id === this._currentConfig.id) continue; 
                    
                    if ('requestIdleCallback' in window) requestIdleCallback(() => loadOne(c), { timeout: 1500 });
                    else setTimeout(() => loadOne(c), 500 + (i * 200));
                }
            };
            schedule();
        }

        /**
         * Switches the active iframe to the specified configuration.
         * @param {DashboardConfig} config - The configuration object to load.
         */
        showIframe = (config) => {
            const { id, url, label } = config;

            if (this._currentConfig && this._currentConfig.id === id) {
                this.showToast(`${label} is already active`, 1000);
                return;
            }
            
            // 1. Hide previous iframe and update state
            if (this._currentConfig && this._iframeMap.has(this._currentConfig.id)) {
                const prev = this._iframeMap.get(this._currentConfig.id);
                prev.style.display = 'none';
                prev.classList.remove('active');
            }
            this._currentConfig = config;

            // Update URL hash for deep linking
            history.pushState(null, '', `#${id}`);
            
            // Update sidebar active state
            this.navLinks.forEach(x => x.classList.remove('active'));
            const activeLink = this.navLinks.find(l => l.getAttribute('data-id') === id);
            if (activeLink) activeLink.classList.add('active');
            
            // 2. Show existing or create new iframe
            if (this._iframeMap.has(id)) {
                const f = this._iframeMap.get(id);
                f.style.display = 'block';
                f.classList.add('active');
                PrefManager.setPref('lastSheetId', id);
                this.el.titleText.textContent = label || 'Elkayem Dashboard';
                this.hideLoading();
                this.scaleViewport();
                this.showToast(`Loaded: ${label}`);
                return;
            }

            // Create and load new iframe
            this.showLoading();
            this._iframeLoadState.set(id, true);
            const f = document.createElement('iframe');
            f.src = url;
            f.loading = 'eager'; 
            f.referrerPolicy = 'no-referrer-when-downgrade';
            // Security: Sandboxing the iframe to prevent harmful actions
            f.setAttribute('sandbox', 'allow-scripts allow-forms allow-same-origin allow-popups'); 
            f.style.display = 'block';
            f.classList.add('active');
            f.title = label || 'Embedded Report';

            const t0 = performance.now();
            f.onload = () => {
                this._iframeLoadState.set(id, false);
                this.hideLoading();
                PrefManager.setPref('lastSheetId', id);
                this.el.titleText.textContent = label || 'Elkayem Dashboard';
                this.scaleViewport();
                const took = Math.round(performance.now() - t0);
                this.showToast(`Loaded: ${label} (${took}ms)`);
                this.log(`Iframe loaded ${url} in ${took}ms`);
            };
            f.onerror = (ev) => {
                this._iframeLoadState.set(id, false);
                this.hideLoading();
                f.remove();
                this._iframeMap.delete(id);
                this.showToast(`Failed to load: ${label}`, 2600);
                this.log('Iframe error: ' + url + ' ' + (ev && ev.message ? ev.message : 'error'));
            };

            this._iframeMap.set(id, f);
            this.el.iframeShell.appendChild(f);
            this._calculateIframeHeight();

            // Fail-safe timeout
            setTimeout(() => {
                if (this._iframeLoadState.get(id)) {
                    this._iframeLoadState.set(id, false);
                    this.hideLoading();
                    this.showToast('Load timeout', 2000);
                    this.log('Load timeout ' + url);
                }
            }, 25000);
        }

        /** Forces a refresh (reload) of the currently active iframe by resetting its SRC attribute. */
        refreshCurrent = () => {
            if (!this._currentConfig || !this._iframeMap.has(this._currentConfig.id)) {
                this.showToast('Nothing to refresh', 1200);
                return;
            }
            this.showLoading();
            const f = this._iframeMap.get(this._currentConfig.id);
            const t0 = performance.now();
            const label = this._currentConfig.label;
            const oldSrc = f.src;

            const onRefreshLoad = () => {
                this.hideLoading();
                const took = Math.round(performance.now() - t0);
                this.showToast(`Refreshed: ${label} (${took}ms)`);
                f.removeEventListener('load', onRefreshLoad);
                f.removeEventListener('error', onRefreshError);
            };
            const onRefreshError = () => {
                this.hideLoading();
                this.showToast(`Refresh failed: ${label}`, 2600);
                f.removeEventListener('load', onRefreshLoad);
                f.removeEventListener('error', onRefreshError);
            }

            f.addEventListener('load', onRefreshLoad);
            f.addEventListener('error', onRefreshError);

            try {
                // Standard technique to force a full reload without destroying the element
                f.src = 'about:blank'; 
                setTimeout(() => { f.src = oldSrc; }, 10); 
                this.log('Refreshed (reset src): ' + oldSrc);
            } catch (err) {
                this.hideLoading();
                this.showToast('Refresh failed due to error.', 1200);
                this.log('Refresh failed: ' + err.message);
            }
        }

        /** Handles URL hash changes (browser back/forward button) for deep linking. */
        handleHashChange = () => {
            const hash = window.location.hash.substring(1);
            if (!hash) return;
            const config = this._getConfigById(hash);
            if (config) {
                this.showIframe(config);
            } else {
                this.log(`Hash change to unknown ID: ${hash}`);
            }
        }

        /** Binds all necessary event listeners. */
        bindEvents = () => {
            this.el.sidebarToggle.addEventListener('click', this.handleSidebarToggle);

            this.navLinks.forEach(l => {
                l.setAttribute('tabindex', '0');
                l.addEventListener('keydown', e => {
                    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); l.click(); }
                });
                l.addEventListener('click', this.handleNavLinkClick);
            });

            this.el.refreshBtn.addEventListener('click', this.refreshCurrent);
            this.el.darkToggle.addEventListener('click', this.handleDarkToggle);
            this.el.debugToggle.addEventListener('click', this.handleDebugToggle);
            this.el.debugClear.addEventListener('click', () => { this.el.debugBody.innerHTML = ''; });
            this.el.debugClose.addEventListener('click', () => { this.el.debugPanel.classList.remove('open'); this.el.debugPanel.setAttribute('aria-hidden', 'true'); });

            this.el.zoomSlider.addEventListener('input', e => this._setManualScale(Number(e.target.value)));
            this.el.autoScaleCheckbox.addEventListener('change', this.handleAutoScaleChange);
            this.el.zoomInBtn.addEventListener('click', () => this._handleZoomButton(10));
            this.el.zoomOutBtn.addEventListener('click', () => this._handleZoomButton(-10));
            this.el.zoomResetBtn.addEventListener('click', this.resetZoom);

            this._setupResizer();

            window.addEventListener('resize', debounce(this.scaleViewport, 120));
            window.addEventListener('orientationchange', () => setTimeout(this.scaleViewport, 220));
            window.addEventListener('keydown', this.handleGlobalKeydown);
            window.addEventListener('hashchange', this.handleHashChange); // Handle deep linking navigation

            // Observe iframe shell for changes
            const observer = new MutationObserver(debounce(this.scaleViewport, 120));
            observer.observe(this.el.iframeShell, { childList: true, subtree: true, attributes: false });
            
            this._setupTouchSwipe();
        }

        /** Handles sidebar open/collapse logic for both desktop and mobile. */
        handleSidebarToggle = () => {
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                const open = this.el.sidebar.classList.toggle('open');
                this.el.sidebarToggle.setAttribute('aria-pressed', open ? 'true' : 'false');
                this.showToast(open ? 'Menu opened' : 'Menu closed', 900);
            } else {
                const collapsed = this.el.sidebar.classList.toggle('collapsed');
                this.el.sidebarToggle.setAttribute('aria-pressed', collapsed ? 'true' : 'false');
                const icon = this.el.sidebarToggle.querySelector('i');
                if (icon) {
                    icon.classList.toggle('fa-chevron-right', collapsed);
                    icon.classList.toggle('fa-chevron-left', !collapsed);
                }
                PrefManager.setPref('sidebarCollapsed', collapsed ? '1' : '0');
                this.showToast(collapsed ? 'Sidebar collapsed' : 'Sidebar expanded', 900);
                setTimeout(this.scaleViewport, 220); // Recalculate scale after transition
            }
        }
/** Handles clicking a navigation link. */
handleNavLinkClick = (e) => {
    e.preventDefault();
    const id = e.currentTarget.getAttribute('data-id');
    const config = this._getConfigById(id);
    if (!config) { this.showToast('Configuration error: missing source', 1200); return; }
    
    // Check if the link is a GitHub site or a PDF file (these usually block iframes)
    const isRestricted = config.url.includes('github.io') || config.url.toLowerCase().endsWith('.pdf');

    if (isRestricted) {
        // Open in a new tab to bypass Chrome's "Blocked" error
        window.open(config.url, '_blank');
        this.showToast(`Opening ${config.label} in new tab...`);
        
        // Close sidebar on mobile
        if (window.innerWidth <= 768) this.el.sidebar.classList.remove('open');
        return;
    }

    // Otherwise, load in the dashboard iframe (standard for OneDrive/Excel)
    if (window.innerWidth <= 768) this.el.sidebar.classList.remove('open');
    this.showIframe(config);
}
        /** Toggles dark/light mode. */
        handleDarkToggle = () => {
            document.body.classList.toggle('dark-mode');
            const dm = document.body.classList.contains('dark-mode') ? '1' : '0';
            PrefManager.setPref('darkMode', dm);
            this.showToast(document.body.classList.contains('dark-mode') ? 'Dark mode enabled' : 'Light mode enabled');
        }

        /** Toggles the debug log panel visibility. */
        handleDebugToggle = () => {
            const open = this.el.debugPanel.classList.toggle('open');
            this.el.debugPanel.setAttribute('aria-hidden', !open);
            this.log(`Debug panel ${open ? 'opened' : 'closed'}`);
        }

        /**
         * Sets the manual scale factor from a percentage value (e.g., from slider).
         * @param {number} percent - The zoom percentage (40 to 150).
         */
        _setManualScale = (percent) => {
            this._manualScale = Math.max(this.ZOOM_MIN, Math.min(this.ZOOM_MAX, percent / 100));
            PrefManager.setPref('manualScale', this._manualScale.toString());
            this.el.autoScaleCheckbox.checked = false;
            this.el.zoomPct.textContent = Math.round(this._manualScale * 100) + '%';
            this.scaleViewport();
        }

        /** Handles the Auto Scale checkbox toggle. */
        handleAutoScaleChange = (e) => {
            if (e.target.checked) {
                this._manualScale = null;
                PrefManager.setPref('manualScale', '');
                this.el.zoomPct.textContent = 'Auto';
                this.scaleViewport();
                this.showToast('Auto scale enabled');
            } else {
                this._setManualScale(Number(this.el.zoomSlider.value));
                this.showToast('Manual scale enabled');
            }
        }

        /**
         * Handles the zoom in/out button clicks.
         * @param {number} step - The percentage step to change by (e.g., 10 or -10).
         */
        _handleZoomButton = (step) => {
            const currentPct = this._manualScale ? Math.round(this._manualScale * 100) : Math.round(this._lastScale * 100);
            const next = Math.max(this.ZOOM_MIN * 100, Math.min(this.ZOOM_MAX * 100, currentPct + step));
            this._setManualScale(next);
            this.el.zoomSlider.value = next;
            this.showToast(step > 0 ? 'Zoom In' : 'Zoom Out');
        }

        /** Resets the zoom to auto-scale (100% on slider). */
        resetZoom = () => {
            this._manualScale = null;
            this.el.autoScaleCheckbox.checked = true;
            PrefManager.setPref('manualScale', '');
            
            this.el.iframeShell.style.width = '';
            this.el.iframeShell.style.height = '';
            
            this.scaleViewport();
            this.el.zoomSlider.value = 100;
            this.el.zoomPct.textContent = 'Auto';
            this.showToast('Zoom Reset (Auto)');
        }

        /** Global keyboard shortcuts handler. */
        handleGlobalKeydown = (e) => {
            const tag = document.activeElement && document.activeElement.tagName.toLowerCase();
            if (tag === 'input' || tag === 'textarea') return;

            if ((e.key === '+' || e.key === '=') && !e.shiftKey) { 
                e.preventDefault();
                this.el.zoomInBtn.click();
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                this.el.zoomOutBtn.click();
            } else if (e.key === '0' && e.ctrlKey) {
                e.preventDefault();
                this.resetZoom();
                this.el.sidebar.classList.remove('collapsed');
                this.el.sidebar.classList.remove('open');
                PrefManager.setPref('sidebarCollapsed', '0');
                this.showToast('Layout and Zoom Reset');
            }
        }

        /** Sets up the drag-to-resize functionality for the iframe shell. */
        _setupResizer = () => {
            let dragging = false;
            let startX = 0;
            let startW = 0;

            const onStart = (clientX) => {
                dragging = true;
                startX = clientX;
                const currentScale = this._lastScale || 1;
                startW = this.el.iframeShell.getBoundingClientRect().width / currentScale;
                this.el.iframeShell.style.transition = 'none';
            }

            const onMove = (clientX) => {
                if (!dragging) return;
                const dx = clientX - startX;
                const newW = Math.max(320, startW + dx);

                this.el.iframeShell.style.width = newW + 'px';
                
                const scale = Math.max(this.ZOOM_MIN, Math.min(this.ZOOM_MAX, newW / this.REF_W));
                this._manualScale = scale;
                this.el.zoomSlider.value = Math.round(scale * 100);
                this.el.autoScaleCheckbox.checked = false;
                this.el.zoomPct.textContent = Math.round(scale * 100) + '%';

                this.scaleViewport();
            }

            const onEnd = () => {
                if (!dragging) return;
                dragging = false;
                PrefManager.setPref('manualScale', this._manualScale.toString());
                this.el.iframeShell.style.transition = 'transform .12s ease';
            }

            const setupDragListeners = (ev) => {
                ev.preventDefault();
                const isTouch = ev.type.startsWith('touch');
                const t = isTouch ? ev.touches[0] : ev;
                onStart(t.clientX, t.clientY);

                const moveHandler = (e) => {
                    const ct = isTouch ? e.touches[0] : e;
                    if (!isTouch || ct) onMove(ct.clientX);
                };
                const upHandler = () => {
                    onEnd();
                    document.removeEventListener(isTouch ? 'touchmove' : 'mousemove', moveHandler, isTouch ? { passive: false } : false);
                    document.removeEventListener(isTouch ? 'touchend' : 'mouseup', upHandler);
                };
                
                document.addEventListener(isTouch ? 'touchmove' : 'mousemove', moveHandler, isTouch ? { passive: false } : false);
                document.addEventListener(isTouch ? 'touchend' : 'mouseup', upHandler);
            };

            this.el.resizeHandle.addEventListener('mousedown', setupDragListeners);
            this.el.resizeHandle.addEventListener('touchstart', setupDragListeners, { passive: false });
            this.el.resizeHandle.addEventListener('dblclick', this.resetZoom);
        }

        /** Sets up swiping logic for mobile sidebar. */
        _setupTouchSwipe = () => {
            let startX = 0, moved = false;
            let sidebarWidth = this.el.sidebar.clientWidth;

            document.addEventListener('touchstart', e => {
                if (e.touches && e.touches[0]) { startX = e.touches[0].clientX; moved = false; }
            }, { passive: true });
            
            document.addEventListener('touchmove', e => {
                if (!e.touches || !e.touches[0]) return;
                const dx = e.touches[0].clientX - startX;
                if (Math.abs(dx) > 6) moved = true;
            }, { passive: true });
            
            document.addEventListener('touchend', e => {
                if (!moved) return;
                const endX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : 0;
                const dx = endX - startX;

                if (startX < 40 && dx > 60) {
                    this.el.sidebar.classList.add('open');
                    this.showToast('Menu opened', 900);
                }
                
                if (startX > 0 && startX < sidebarWidth && dx < -60) {
                    this.el.sidebar.classList.remove('open');
                    this.showToast('Menu closed', 900);
                }
            }, { passive: true });
        }

        /** Performs initial setup and loads stored preferences. */
        init() {
            // 1. Apply dark mode, sidebar collapse, and zoom prefs
            const storedDm = PrefManager.getPref('darkMode');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (storedDm === '1' || (storedDm === null && prefersDark)) {
                document.body.classList.add('dark-mode');
            }
            if (PrefManager.getPref('sidebarCollapsed') === '1' && window.innerWidth > 768) {
                this.el.sidebar.classList.add('collapsed');
                this.el.sidebarToggle.querySelector('i')?.classList.add('fa-chevron-right');
                this.el.sidebarToggle.setAttribute('aria-pressed', 'true');
            }
            const ms = PrefManager.getPref('manualScale');
            if (ms) {
                this._manualScale = Number(ms) || null;
                if (this._manualScale) {
                    this.el.zoomSlider.value = Math.round(this._manualScale * 100);
                    this.el.autoScaleCheckbox.checked = false;
                    this.el.zoomPct.textContent = Math.round(this._manualScale * 100) + '%';
                }
            }

            // 2. Determine initial sheet to load: 
            const hashId = window.location.hash.substring(1);
            const storedId = PrefManager.getPref('lastSheetId');
            
            const initialConfig = this._getConfigById(hashId) || 
                                  this._getConfigById(storedId) || 
                                  this.config[0];
            
            if (initialConfig) {
                this.showIframe(initialConfig);
                this.preload(2); // Start preloading after the initial sheet is determined
            } else {
                this.log('No dashboard links found to load.');
            }

            // 3. Initial viewport calculation and height setting
            setTimeout(() => {
                this.scaleViewport();
                this._calculateIframeHeight();
            }, 300);
            this.log('DashboardApp initialization complete.');
        }
    }


    // --- 3.5. DOM READY / ENTRY POINT ---
    document.addEventListener('DOMContentLoaded', () => {
        // Collect all elements for a single reference object
        const elements = {
            sidebar: document.getElementById('sidebar'),
            sidebarToggle: document.getElementById('sidebarToggle'),
            iframeShell: document.getElementById('iframeShell'),
            iframeViewport: document.getElementById('iframeViewport'),
            loading: document.getElementById('loading'),
            pageHeader: document.getElementById('pageHeader'),
            titleText: document.getElementById('titleText'),
            toastEl: document.getElementById('toast'),
            refreshBtn: document.getElementById('refreshBtn'),
            darkToggle: document.getElementById('darkToggle'),
            debugToggle: document.getElementById('debugToggle'),
            debugPanel: document.getElementById('debugPanel'),
            debugBody: document.getElementById('debugBody'),
            debugClear: document.getElementById('debugClear'),
            debugClose: document.getElementById('debugClose'),
            zoomSlider: document.getElementById('zoomSlider'),
            autoScaleCheckbox: document.getElementById('autoScaleCheckbox'),
            zoomPct: document.getElementById('zoomPct'),
            resizeHandle: document.getElementById('resizeHandle'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            zoomResetBtn: document.getElementById('zoomResetBtn'),
            iframeControls: document.getElementById('iframeControls'),
        };

        // Initialize the application class with elements and the external config
        new DashboardApp(elements, DASHBOARD_CONFIG);
    });
  </script>
</body>
</html>
